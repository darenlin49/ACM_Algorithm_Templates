\subsection{*二维平面图的最大流}
    待整理\\
    \begin{lstlisting}[language=c++]
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <vector>
#include <cmath>
#include <map>
#include <queue>
using namespace std;

const int maxn = 100100;
const int inf = 0x3f3f3f3f;
struct Point
{
    int x,y,id;
    double theta;
    Point() {}
    Point(int _x,int _y)
    {
        x = _x;
        y = _y;
    }
    Point(Point _s,Point _e,int _id)
    {
        id = _id;
        x = _s.x-_e.x;
        y = _s.y-_e.y;
        theta = atan2(y,x);
    }
    bool operator < (const Point &b)const
    {
        return theta < b.theta;
    }
};

map<pair<int,int>,int > idmap;
struct Edge
{
    int from,to,next,cap,near,mark;
};
Edge edge[maxn*2];
int head[maxn],L;
int cntd[maxn];
void addedge(int u,int v,int cap)
{
    cntd[u]++;
    cntd[v]++;
    idmap[make_pair(u,v)] = L;
    edge[L].from = u;
    edge[L].to = v;
    edge[L].cap = cap;
    edge[L].next = head[u];
    edge[L].mark = -1;
    head[u] = L++;
}

int rtp[maxn];
Point p[maxn],tp[maxn];
int n,m,S,T;
int vid;

struct Edge2
{
    int to,next,dis;
} edge2[maxn*2];
int head2[maxn],L2;

void addedge2(int u,int v,int dis)
{
    edge2[L2].to = v;
    edge2[L2].dis = dis;
    edge2[L2].next = head2[u];
    head2[u] = L2++;
}

int dist[maxn];
bool inq[maxn];
int SPFA(int s,int t)
{
    queue<int> Q;
    memset(inq,false,sizeof(inq));
    memset(dist,63,sizeof(dist));
    Q.push(s);
    dist[s] = 0;
    while (!Q.empty())
    {
        int now = Q.front();
        Q.pop();
        for (int i = head2[now]; i != -1; i = edge2[i].next)
            if (dist[edge2[i].to] > dist[now]+edge2[i].dis)
            {
                dist[edge2[i].to] = dist[now]+edge2[i].dis;
                if (inq[edge2[i].to] == false)
                {
                    inq[edge2[i].to] = true;
                    Q.push(edge2[i].to);
                }
            }
        inq[now] = false;
    }
    return dist[t];
}

int main()
{
    int totcas;
    scanf("%d",&totcas);
    for (int cas = 1; cas <= totcas; cas++)
    {
        idmap.clear();
        L = 0;
        scanf("%d%d",&n,&m);
        S = T = 0;
        for (int i = 0; i < n; i++)
        {
            head[i] = -1;
            scanf("%d%d",&p[i].x,&p[i].y);
            if (p[S].x > p[i].x)
                S = i;
            if (p[T].x < p[i].x)
                T = i;
            cntd[i] = 0;
        }
        //源汇中间加入一个特殊节点
        head[n] = -1;
        n ++;
        addedge(S,n-1,inf);
        addedge(n-1,S,inf);
        addedge(T,n-1,inf);
        addedge(n-1,T,inf);

        for (int i = 0; i < m; i++)
        {
            int u,v,cap;
            scanf("%d%d%d",&u,&v,&cap);
            u--;
            v--;
            addedge(u,v,cap);
            addedge(v,u,cap);
        }

        for (int i = 0; i < n; i++)
        {
            int tot = 0;
            //源点汇点连到特殊点的方向需要特别考虑一下
            if (i == S)
                tp[tot++] = Point(Point(0,0),Point(-1,0),n-1);
            else if (i == T)
                tp[tot++] = Point(Point(0,0),Point(1,0),n-1);
            else if (i == n-1)
            {
                tp[tot++] = Point(Point(0,0),Point(1,0),S);
                tp[tot++] = Point(Point(0,0),Point(-1,0),T);
            }
            if (i < n-1)
            {
                for (int j = head[i]; j != -1; j = edge[j].next)
                {
                    if (i == S && edge[j].to == n-1)  continue;
                    if (i == T && edge[j].to == n-1)  continue;
                    tp[tot++] = Point(p[i],p[edge[j].to],edge[j].to);
                }
            }
            sort(tp,tp+tot);
            for (int j = 0; j < tot; j++)
                rtp[tp[j].id] = j;
            for (int j = head[i]; j != -1; j = edge[j].next)
                edge[j].near = tp[(rtp[edge[j].to]+1)%tot].id;
        }

        vid = 0;
        for (int i = 0;i < L;i++)
            if (edge[i].mark == -1)
            {
                int now = edge[i].from;
                int eid = i;
                int to  = edge[i].to;
                while (true)
                {
                    edge[eid].mark = vid;
                    eid ^= 1;
                    now = to;
                    to = edge[eid].near;
                    eid = idmap[make_pair(now,to)];

                    if (now == edge[i].from)    break;
                }
                vid++;
            }

        L2 = 0;
        for (int i = 0; i < vid; i++)
            head2[i] = -1;
        for (int i = 0; i < L; i++)
            addedge2(edge[i].mark,edge[i^1].mark,edge[i].cap);
        printf("%d\n",SPFA(edge[0].mark,edge[1].mark));
    }
    return 0;
}
    \end{lstlisting}